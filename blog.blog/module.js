"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryClient = exports.txClient = exports.registry = exports.MsgCreateComment = exports.MsgCreatePost = exports.MsgDeleteComment = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const tx_1 = require("./types/blog/tx");
Object.defineProperty(exports, "MsgDeleteComment", { enumerable: true, get: function () { return tx_1.MsgDeleteComment; } });
const tx_2 = require("./types/blog/tx");
Object.defineProperty(exports, "MsgCreatePost", { enumerable: true, get: function () { return tx_2.MsgCreatePost; } });
const tx_3 = require("./types/blog/tx");
Object.defineProperty(exports, "MsgCreateComment", { enumerable: true, get: function () { return tx_3.MsgCreateComment; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendMsgDeleteComment({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgDeleteComment: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgDeleteComment({ value: tx_1.MsgDeleteComment.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgDeleteComment: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreatePost({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreatePost: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgCreatePost({ value: tx_2.MsgCreatePost.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreatePost: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateComment({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateComment: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgCreateComment({ value: tx_3.MsgCreateComment.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateComment: Could not broadcast Tx: ' + e.message);
            }
        },
        msgDeleteComment({ value }) {
            try {
                return { typeUrl: "/blog.blog.MsgDeleteComment", value: tx_1.MsgDeleteComment.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgDeleteComment: Could not create message: ' + e.message);
            }
        },
        msgCreatePost({ value }) {
            try {
                return { typeUrl: "/blog.blog.MsgCreatePost", value: tx_2.MsgCreatePost.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreatePost: Could not create message: ' + e.message);
            }
        },
        msgCreateComment({ value }) {
            try {
                return { typeUrl: "/blog.blog.MsgCreateComment", value: tx_3.MsgCreateComment.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateComment: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseUrl: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        var _a;
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.tx = (0, exports.txClient)({ signer: client.signer, addr: client.env.rpcURL, prefix: (_a = client.env.prefix) !== null && _a !== void 0 ? _a : "cosmos" });
    }
}
;
const Module = (test) => {
    return {
        module: {
            BlogBlog: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = Module;
