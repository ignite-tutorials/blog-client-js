"use strict";
// Generated by Ignite ignite.com/cli
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryClient = exports.txClient = exports.registry = exports.MsgVote = exports.MsgUpdateGroupPolicyDecisionPolicy = exports.MsgUpdateGroupAdmin = exports.MsgLeaveGroup = exports.MsgSubmitProposal = exports.MsgUpdateGroupPolicyAdmin = exports.MsgUpdateGroupMetadata = exports.MsgCreateGroupWithPolicy = exports.MsgCreateGroup = exports.MsgUpdateGroupPolicyMetadata = exports.MsgExec = exports.MsgCreateGroupPolicy = exports.MsgUpdateGroupMembers = exports.MsgWithdrawProposal = void 0;
const stargate_1 = require("@cosmjs/stargate");
const proto_signing_1 = require("@cosmjs/proto-signing");
const registry_1 = require("./registry");
const rest_1 = require("./rest");
const tx_1 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgWithdrawProposal", { enumerable: true, get: function () { return tx_1.MsgWithdrawProposal; } });
const tx_2 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgUpdateGroupMembers", { enumerable: true, get: function () { return tx_2.MsgUpdateGroupMembers; } });
const tx_3 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgCreateGroupPolicy", { enumerable: true, get: function () { return tx_3.MsgCreateGroupPolicy; } });
const tx_4 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgExec", { enumerable: true, get: function () { return tx_4.MsgExec; } });
const tx_5 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgUpdateGroupPolicyMetadata", { enumerable: true, get: function () { return tx_5.MsgUpdateGroupPolicyMetadata; } });
const tx_6 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgCreateGroup", { enumerable: true, get: function () { return tx_6.MsgCreateGroup; } });
const tx_7 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgCreateGroupWithPolicy", { enumerable: true, get: function () { return tx_7.MsgCreateGroupWithPolicy; } });
const tx_8 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgUpdateGroupMetadata", { enumerable: true, get: function () { return tx_8.MsgUpdateGroupMetadata; } });
const tx_9 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgUpdateGroupPolicyAdmin", { enumerable: true, get: function () { return tx_9.MsgUpdateGroupPolicyAdmin; } });
const tx_10 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgSubmitProposal", { enumerable: true, get: function () { return tx_10.MsgSubmitProposal; } });
const tx_11 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgLeaveGroup", { enumerable: true, get: function () { return tx_11.MsgLeaveGroup; } });
const tx_12 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgUpdateGroupAdmin", { enumerable: true, get: function () { return tx_12.MsgUpdateGroupAdmin; } });
const tx_13 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgUpdateGroupPolicyDecisionPolicy", { enumerable: true, get: function () { return tx_13.MsgUpdateGroupPolicyDecisionPolicy; } });
const tx_14 = require("./types/cosmos/group/v1/tx");
Object.defineProperty(exports, "MsgVote", { enumerable: true, get: function () { return tx_14.MsgVote; } });
exports.registry = new proto_signing_1.Registry(registry_1.msgTypes);
const defaultFee = {
    amount: [],
    gas: "200000",
};
const txClient = ({ signer, prefix, addr } = { addr: "http://localhost:26657", prefix: "cosmos" }) => {
    return {
        async sendMsgWithdrawProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgWithdrawProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgWithdrawProposal({ value: tx_1.MsgWithdrawProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgWithdrawProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateGroupMembers({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateGroupMembers: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgUpdateGroupMembers({ value: tx_2.MsgUpdateGroupMembers.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateGroupMembers: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateGroupPolicy({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateGroupPolicy: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgCreateGroupPolicy({ value: tx_3.MsgCreateGroupPolicy.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateGroupPolicy: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgExec({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgExec: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgExec({ value: tx_4.MsgExec.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgExec: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateGroupPolicyMetadata({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateGroupPolicyMetadata: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgUpdateGroupPolicyMetadata({ value: tx_5.MsgUpdateGroupPolicyMetadata.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateGroupPolicyMetadata: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateGroup({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateGroup: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgCreateGroup({ value: tx_6.MsgCreateGroup.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateGroup: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgCreateGroupWithPolicy({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgCreateGroupWithPolicy: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgCreateGroupWithPolicy({ value: tx_7.MsgCreateGroupWithPolicy.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgCreateGroupWithPolicy: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateGroupMetadata({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateGroupMetadata: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgUpdateGroupMetadata({ value: tx_8.MsgUpdateGroupMetadata.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateGroupMetadata: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateGroupPolicyAdmin({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateGroupPolicyAdmin: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgUpdateGroupPolicyAdmin({ value: tx_9.MsgUpdateGroupPolicyAdmin.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateGroupPolicyAdmin: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgSubmitProposal({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgSubmitProposal: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgSubmitProposal({ value: tx_10.MsgSubmitProposal.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgSubmitProposal: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgLeaveGroup({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgLeaveGroup: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgLeaveGroup({ value: tx_11.MsgLeaveGroup.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgLeaveGroup: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateGroupAdmin({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateGroupAdmin: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgUpdateGroupAdmin({ value: tx_12.MsgUpdateGroupAdmin.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateGroupAdmin: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgUpdateGroupPolicyDecisionPolicy({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgUpdateGroupPolicyDecisionPolicy: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgUpdateGroupPolicyDecisionPolicy({ value: tx_13.MsgUpdateGroupPolicyDecisionPolicy.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgUpdateGroupPolicyDecisionPolicy: Could not broadcast Tx: ' + e.message);
            }
        },
        async sendMsgVote({ value, fee, memo }) {
            if (!signer) {
                throw new Error('TxClient:sendMsgVote: Unable to sign Tx. Signer is not present.');
            }
            try {
                const { address } = (await signer.getAccounts())[0];
                const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(addr, signer, { registry: exports.registry, prefix });
                let msg = this.msgVote({ value: tx_14.MsgVote.fromPartial(value) });
                return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo);
            }
            catch (e) {
                throw new Error('TxClient:sendMsgVote: Could not broadcast Tx: ' + e.message);
            }
        },
        msgWithdrawProposal({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgWithdrawProposal", value: tx_1.MsgWithdrawProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgWithdrawProposal: Could not create message: ' + e.message);
            }
        },
        msgUpdateGroupMembers({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers", value: tx_2.MsgUpdateGroupMembers.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateGroupMembers: Could not create message: ' + e.message);
            }
        },
        msgCreateGroupPolicy({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy", value: tx_3.MsgCreateGroupPolicy.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateGroupPolicy: Could not create message: ' + e.message);
            }
        },
        msgExec({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgExec", value: tx_4.MsgExec.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgExec: Could not create message: ' + e.message);
            }
        },
        msgUpdateGroupPolicyMetadata({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", value: tx_5.MsgUpdateGroupPolicyMetadata.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateGroupPolicyMetadata: Could not create message: ' + e.message);
            }
        },
        msgCreateGroup({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgCreateGroup", value: tx_6.MsgCreateGroup.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateGroup: Could not create message: ' + e.message);
            }
        },
        msgCreateGroupWithPolicy({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy", value: tx_7.MsgCreateGroupWithPolicy.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgCreateGroupWithPolicy: Could not create message: ' + e.message);
            }
        },
        msgUpdateGroupMetadata({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata", value: tx_8.MsgUpdateGroupMetadata.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateGroupMetadata: Could not create message: ' + e.message);
            }
        },
        msgUpdateGroupPolicyAdmin({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", value: tx_9.MsgUpdateGroupPolicyAdmin.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateGroupPolicyAdmin: Could not create message: ' + e.message);
            }
        },
        msgSubmitProposal({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgSubmitProposal", value: tx_10.MsgSubmitProposal.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgSubmitProposal: Could not create message: ' + e.message);
            }
        },
        msgLeaveGroup({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgLeaveGroup", value: tx_11.MsgLeaveGroup.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgLeaveGroup: Could not create message: ' + e.message);
            }
        },
        msgUpdateGroupAdmin({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin", value: tx_12.MsgUpdateGroupAdmin.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateGroupAdmin: Could not create message: ' + e.message);
            }
        },
        msgUpdateGroupPolicyDecisionPolicy({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", value: tx_13.MsgUpdateGroupPolicyDecisionPolicy.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgUpdateGroupPolicyDecisionPolicy: Could not create message: ' + e.message);
            }
        },
        msgVote({ value }) {
            try {
                return { typeUrl: "/cosmos.group.v1.MsgVote", value: tx_14.MsgVote.fromPartial(value) };
            }
            catch (e) {
                throw new Error('TxClient:MsgVote: Could not create message: ' + e.message);
            }
        },
    };
};
exports.txClient = txClient;
const queryClient = ({ addr: addr } = { addr: "http://localhost:1317" }) => {
    return new rest_1.Api({ baseURL: addr });
};
exports.queryClient = queryClient;
class SDKModule {
    constructor(client) {
        this.registry = [];
        this.query = (0, exports.queryClient)({ addr: client.env.apiURL });
        this.updateTX(client);
        client.on('signer-changed', (signer) => {
            this.updateTX(client);
        });
    }
    updateTX(client) {
        var _a;
        const methods = (0, exports.txClient)({
            signer: client.signer,
            addr: client.env.rpcURL,
            prefix: (_a = client.env.prefix) !== null && _a !== void 0 ? _a : "cosmos",
        });
        this.tx = methods;
        for (let m in methods) {
            this.tx[m] = methods[m].bind(this.tx);
        }
    }
}
;
const Module = (test) => {
    return {
        module: {
            CosmosGroupV1: new SDKModule(test)
        },
        registry: registry_1.msgTypes
    };
};
exports.default = Module;
